import collections
from abc import abstractmethod
from random import randrange

import gym
import numpy as np
from loguru import logger

from vimms.ChemicalSamplers import UniformMZFormulaSampler, UniformRTAndIntensitySampler
from vimms.Chemicals import ChemicalMixtureCreator
from vimms.Common import set_log_level_warning
from vimms.Controller import TopNController
from vimms.Environment import Environment
from vimms.MassSpec import IndependentMassSpectrometer
from vimms.Noise import UniformSpikeNoise


class VimmsGymEnv(gym.Env):
    """
    Wrapper ViMMS Environment that follows gym interface
    """
    metadata = {'render.modes': ['human']}

    def __init__(self, in_dim, out_dim, params):
        super().__init__()
        assert len(params) > 0
        self.in_dim = in_dim
        self.out_dim = out_dim
        self.action_space = self._get_action_space()
        self.observation_space = self._get_observation_space()
        self.step_no = 0

        self.chemical_creator_params = params['chemical_creator']
        self.noise_params = params['noise']
        self.env_params = params['env']

        self.mass_spec = None
        self.controller = None
        self.vimms_env = None
        self._initial_values()

    @abstractmethod
    def _get_action_space(self):
        pass

    @abstractmethod
    def _get_observation_space(self):
        pass

    @abstractmethod
    def _get_state(self, scan_to_process):
        pass

    @abstractmethod
    def _compute_reward(self, scan_to_process, results):
        pass

    @abstractmethod
    def _take_action(self, action):
        pass

    def _initial_values(self):
        """
        Sets some initial values
        """
        if self.mass_spec is not None:
            self.mass_spec.fire_event(IndependentMassSpectrometer.ACQUISITION_STREAM_CLOSED)
            self.mass_spec.close()

        if self.vimms_env is not None:
            self.vimms_env.close_progress_bar()

        self.chems = []
        self.scan_to_process = None
        self.state = np.zeros(self.in_dim)
        self.episode_done = False
        self.last_processed_scan = None
        self.last_reward = 0.0
        self.seen_chems = {}
        self.seen_actions = collections.Counter()

        # needed for SubprocVecEnv
        set_log_level_warning()

    def step(self, action):
        """
        Execute one time step within the environment
        One step = a block of MS2 scans + 1 MS1 scan
        """
        self.step_no += 1
        self._take_action(action)
        results, next_scan_to_process, episode_done = self._one_step(self.scan_to_process)
        self.last_reward = self._compute_reward(self.scan_to_process, results)
        self.last_processed_scan = self.scan_to_process

        # get next scan and next state
        if next_scan_to_process is not None:
            self.scan_to_process = next_scan_to_process
            self.state = self._get_state(self.scan_to_process)
        else:
            episode_done = True
        self.episode_done = episode_done
        info = {}
        return self.state, self.last_reward, self.episode_done, info

    def _one_step(self, scan_to_process):
        """
        Take one step, defined here as processing one ms1 scan, and
        computing the reward from all its resulting ms2 scans
        """
        results = []
        next_scan_to_process = None

        # process ms1 scan. New ms2 tasks will be generated by the controller
        episode_done = self._process_scan(scan_to_process)
        if episode_done:
            return results, next_scan_to_process, episode_done

        # Assuming some new ms2 tasks have been scheduled. Advance mass spec to process the ms2 scans too
        next_processed_scan_id = self.controller.next_processed_scan_id
        while True:

            # generate new scan but don't call the controller yet
            new_scan = self.mass_spec.step(call_controller=False)

            # this could only happen if the mass spec tasks queue is empty and controller doesn't schedule any new scan
            assert new_scan is not None

            if new_scan.scan_id == next_processed_scan_id:
                # found the next scan to process, mark end of a block
                next_scan_to_process = new_scan
                break
            else:
                # otherwise assume it's all ms2 scans, save this for reward calculation later
                results.append(new_scan)

            # for most controller, this doesn't really do anything
            # however time is still incremented here, so we need to check
            episode_done = self._process_scan(new_scan)
            if episode_done:
                break

        return results, next_scan_to_process, episode_done

    def _process_scan(self, scan):
        """
        Advance the simulation by processing one scan
        """
        self.mass_spec.dispatch_scan(scan)
        self.controller.update_state_after_scan(scan)
        self.vimms_env._update_progress_bar(scan)
        episode_done = True if self.mass_spec.time > self.vimms_env.max_time else False
        return episode_done

    def reset(self):
        """
        Reset the state of the environment to an initial state
        """
        # 1. Reset initial states
        self._initial_values()

        # 2. Reset generated chemicals
        self.chems = self._get_chemicals(self.chemical_creator_params)

        # 3. Reset ViMMS environment
        self.mass_spec = self._reset_mass_spec(self.chems, self.env_params, self.noise_params)
        self.controller = self._reset_controller(self.env_params)
        self.vimms_env = self._reset_vimms_environment(self.mass_spec, self.controller, self.env_params)

        # 4. Generate the initial scan in vimms environment
        self.vimms_env._set_initial_values()
        self.mass_spec.register_event(IndependentMassSpectrometer.MS_SCAN_ARRIVED, self.vimms_env.add_scan)
        self.mass_spec.register_event(IndependentMassSpectrometer.ACQUISITION_STREAM_OPENING,
                                      self._handle_acquisition_open)
        self.mass_spec.register_event(IndependentMassSpectrometer.ACQUISITION_STREAM_CLOSED,
                                      self.vimms_env.handle_acquisition_closing)
        self.mass_spec.register_event(IndependentMassSpectrometer.STATE_CHANGED,
                                      self.vimms_env.handle_state_changed)

        # 5. Generate initial scan when the acquisition opens
        self.mass_spec.fire_event(
            IndependentMassSpectrometer.ACQUISITION_STREAM_OPENING)  # call self._handle_acquisition_open() below
        self.episode_done = False
        self.state = self._get_state(self.scan_to_process)
        return self.state

    def _reset_mass_spec(self, chems, env_params, noise_params):
        """
        Generates new mass spec
        """
        noise_density = noise_params['noise_density']
        noise_max_val = noise_params['noise_max_val']
        noise_min_mz = noise_params['mz_range'][0]
        noise_max_mz = noise_params['mz_range'][1]
        spike_noise = UniformSpikeNoise(noise_density, noise_max_val, min_mz=noise_min_mz, max_mz=noise_max_mz)
        ionisation_mode = env_params['ionisation_mode']
        mass_spec = IndependentMassSpectrometer(ionisation_mode, chems, None, spike_noise=spike_noise)
        return mass_spec

    def _reset_controller(self, env_params):
        """
        Generates new controller
        """
        ionisation_mode = env_params['ionisation_mode']
        N = env_params['N']
        isolation_window = env_params['isolation_window']
        mz_tol = env_params['mz_tol']
        rt_tol = env_params['rt_tol']
        min_ms1_intensity = env_params['min_ms1_intensity']
        controller = TopNController(ionisation_mode, N, isolation_window, mz_tol, rt_tol, min_ms1_intensity,
                                    ms1_shift=0,
                                    initial_exclusion_list=None, force_N=False)
        return controller

    def _reset_vimms_environment(self, mass_spec, controller, env_params):
        """
        Generates new ViMMS environment to run controller and mass spec together
        """
        min_rt = env_params['rt_range'][0]
        max_rt = env_params['rt_range'][1]
        vimms_env = Environment(mass_spec, controller, min_rt, max_rt, progress_bar=False)
        return vimms_env

    def _get_chemicals(self, chemical_creator_params):
        """
        Generates new set of chemicals
        """
        min_mz = chemical_creator_params['mz_range'][0]
        max_mz = chemical_creator_params['mz_range'][1]
        min_rt = chemical_creator_params['rt_range'][0]
        max_rt = chemical_creator_params['rt_range'][1]
        min_log_intensity = np.log(chemical_creator_params['intensity_range'][0])
        max_log_intensity = np.log(chemical_creator_params['intensity_range'][1])
        n_chemicals_range = chemical_creator_params['n_chemicals']
        if n_chemicals_range[0] == n_chemicals_range[1]:
            n_chems = n_chemicals_range[0]
        else:
            n_chems = randrange(n_chemicals_range[0], n_chemicals_range[1])

        if 'mz_sampler' in chemical_creator_params:
            mz_sampler = chemical_creator_params['mz_sampler']
        else:  # sample chemicals uniformly
            mz_sampler = UniformMZFormulaSampler(min_mz=min_mz, max_mz=max_mz)

        if 'rt_sampler' in chemical_creator_params:
            ri_sampler = chemical_creator_params['ri_sampler']
        else:
            ri_sampler = UniformRTAndIntensitySampler(min_rt=min_rt, max_rt=max_rt,
                                                      min_log_intensity=min_log_intensity,
                                                      max_log_intensity=max_log_intensity)

        cm = ChemicalMixtureCreator(mz_sampler, rt_and_intensity_sampler=ri_sampler)
        chems = cm.sample(n_chems, 2, include_adducts_isotopes=False)
        return chems

    def _handle_acquisition_open(self):
        """
        Open acquisition and generates an MS1 scan to process
        """
        logger.debug('Acquisition open')
        # send the initial custom scan to start the custom scan generation process
        params = self.controller.get_initial_scan_params()

        # unlike the normal Vimms environment, here we generate scan but don't call the controller yet (time is also not incremented)
        self.scan_to_process = self.mass_spec.step(params=params, call_controller=False)

    def _get_mzs_rt_intensities(self, scan_to_process):
        """
        Extracts mzs, rt, and intensities values from a scan
        """
        mzs = scan_to_process.mzs
        intensities = scan_to_process.intensities
        rt = scan_to_process.rt
        assert mzs.shape == intensities.shape
        return mzs, rt, intensities

    def render(self, mode='human', close=False):
        """
        Render the environment to the screen
        """
        logger.info('step %d %s reward %f done %s seen_actions %s' % (self.step_no, self.last_processed_scan,
                                                                      self.last_reward, self.episode_done,
                                                                      self.seen_actions.most_common()))
