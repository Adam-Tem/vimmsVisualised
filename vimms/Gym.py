from random import randrange

import gym
import numpy as np
from gym import spaces
from loguru import logger

from vimms.ChemicalSamplers import UniformMZFormulaSampler
from vimms.Chemicals import ChemicalMixtureCreator, UniformRTAndIntensitySampler
from vimms.Common import ScanParameters
from vimms.Controller import TopNController
from vimms.Environment import Environment
from vimms.MassSpec import IndependentMassSpectrometer
from vimms.Noise import UniformSpikeNoise


class FragmentEnv(gym.Env):
    """
    Wrapper ViMMS Environment that follows gym interface
    """
    metadata = {'render.modes': ['human']}

    def __init__(self, params):
        super().__init__()
        self.in_dim = 20
        self.out_dim = 10
        self.action_space = spaces.Discrete(self.out_dim)
        self.observation_space = spaces.Box(np.array([0.0] * self.in_dim), np.array([np.inf] * self.in_dim))
        self.step_no = 0

        self.chemical_creator_params = params['chemical_creator']
        self.noise_params = params['noise']
        self.env_params = params['env']

        self.mass_spec = None
        self.controller = None
        self.vimms_env = None
        self._initial_values()

    def _initial_values(self):
        """
        Sets some initial values
        """
        if self.mass_spec is not None:
            self.mass_spec.fire_event(IndependentMassSpectrometer.ACQUISITION_STREAM_CLOSED)
            self.mass_spec.close()

        if self.vimms_env is not None:
            self.vimms_env.close_progress_bar()

        self.chems = []
        self.scan_to_process = None
        self.state = np.zeros(self.in_dim)
        self.episode_done = False
        self.last_processed_scan = None
        self.last_reward = 0.0
        self.seen_chems = {}

    def step(self, action):
        """
        Execute one time step within the environment
        One step = a block of MS2 scans + 1 MS1 scan
        """
        self.step_no += 1
        self._take_action(action)
        results, next_scan_to_process, episode_done = self._one_step(self.scan_to_process)
        self.last_reward = self._compute_reward(self.scan_to_process, results)
        self.last_processed_scan = self.scan_to_process

        # get next scan and next state
        if next_scan_to_process is not None:
            self.scan_to_process = next_scan_to_process
            self.state = self._get_state(self.scan_to_process)
        else:
            episode_done = True
        self.episode_done = episode_done
        info = {}
        return self.state, self.last_reward, self.episode_done, info

    def _take_action(self, action):
        """
        Modify controller variables based on the selected action
        """
        # assume 10 action space
        # TODO: would be good to have some kind of interface for this??
        if 0 <= action < 5:
            self.controller.N = (action + 1) * 5  # N = {5, 10, 15, 20, 25}
        elif 5 <= action < 10:
            self.controller.rt_tol = (action - 5 + 1) * 5  # rt_tol = {5, 10, 15, 20, 25}

    def _one_step(self, scan_to_process):
        """
        Take one step, defined here as processing one ms1 scan, and
        computing the reward from all its resulting ms2 scans
        """
        results = []
        next_scan_to_process = None

        # process ms1 scan. New ms2 tasks will be generated by the controller
        episode_done = self._process_scan(scan_to_process)
        if episode_done:
            return results, next_scan_to_process, episode_done

        # Assuming some new ms2 tasks have been scheduled. Advance mass spec to process the ms2 scans too
        next_processed_scan_id = self.controller.next_processed_scan_id
        while True:

            # generate new scan but don't call the controller yet
            new_scan = self.mass_spec.step(call_controller=False)

            # this could only happen if the mass spec tasks queue is empty and controller doesn't schedule any new scan
            assert new_scan is not None

            if new_scan.scan_id == next_processed_scan_id:
                # found the next scan to process, mark end of a block
                next_scan_to_process = new_scan
                break
            else:
                # otherwise assume it's all ms2 scans, save this for reward calculation later
                results.append(new_scan)

            # for most controller, this doesn't really do anything
            # however time is still incremented here, so we need to check
            episode_done = self._process_scan(new_scan)
            if episode_done:
                break

        return results, next_scan_to_process, episode_done

    def _compute_reward(self, scan_to_process, results):
        """
        Computes fragmentation reward
        """
        total_reward = 0.0
        for last_scan in results:
            if last_scan.ms_level >= 2:

                event = last_scan.fragevent
                if event is not None:  # fragmenting chems
                    frag_intensity = event.parents_intensity[0]
                    chem = event.chem
                    if chem in self.seen_chems:
                        self.seen_chems[chem] += 1
                    else:
                        self.seen_chems[chem] = 1

                    reward = 0
                    if frag_intensity is not None:
                        if frag_intensity > self.controller.min_ms1_intensity:
                            reward = frag_intensity * 1.0 / self.seen_chems[chem]
                            reward = np.log(reward)
                    parent_scan_id = event.precursor_mz[0].precursor_scan_id

                else:  # fragmenting noise
                    precursor = last_scan.scan_params.get(ScanParameters.PRECURSOR_MZ)[0]
                    intensity = precursor.precursor_intensity
                    reward = 0
                    if intensity > self.controller.min_ms1_intensity:
                        reward = -np.log(intensity)
                    parent_scan_id = self.controller.last_ms1_scan.scan_id

                assert scan_to_process.scan_id == parent_scan_id
                total_reward += reward

        return total_reward

    def _process_scan(self, scan):
        """
        Advance the simulation by processing one scan
        """
        self.mass_spec.dispatch_scan(scan)
        self.controller.update_state_after_scan(scan)
        self.vimms_env._update_progress_bar(scan)
        episode_done = True if self.mass_spec.time > self.vimms_env.max_time else False
        return episode_done

    def reset(self):
        """
        Reset the state of the environment to an initial state
        """
        # 1. Reset initial states
        self._initial_values()

        # 2. Reset generated chemicals
        self.chems = self._reset_chemicals(self.chemical_creator_params)

        # 3. Reset ViMMS environment
        self.mass_spec = self._reset_mass_spec(self.chems, self.env_params, self.noise_params)
        self.controller = self._reset_controller(self.env_params)
        self.vimms_env = self._reset_vimms_environment(self.mass_spec, self.controller, self.env_params)

        # 4. Generate the initial scan in vimms environment
        self.vimms_env._set_initial_values()
        self.mass_spec.register_event(IndependentMassSpectrometer.MS_SCAN_ARRIVED, self.vimms_env.add_scan)
        self.mass_spec.register_event(IndependentMassSpectrometer.ACQUISITION_STREAM_OPENING,
                                      self._handle_acquisition_open)
        self.mass_spec.register_event(IndependentMassSpectrometer.ACQUISITION_STREAM_CLOSED,
                                      self.vimms_env.handle_acquisition_closing)
        self.mass_spec.register_event(IndependentMassSpectrometer.STATE_CHANGED,
                                      self.vimms_env.handle_state_changed)

        # 5. Generate initial scan when the acquisition opens
        self.mass_spec.fire_event(
            IndependentMassSpectrometer.ACQUISITION_STREAM_OPENING)  # call self._handle_acquisition_open() below
        self.episode_done = False
        self.state = self._get_state(self.scan_to_process)
        return self.state

    def _reset_chemicals(self, chemical_creator_params):
        """
        Generates new set of chemicals
        """
        min_mz = chemical_creator_params['mz_range'][0]
        max_mz = chemical_creator_params['mz_range'][1]
        min_rt = chemical_creator_params['rt_range'][0]
        max_rt = chemical_creator_params['rt_range'][1]
        min_log_intensity = np.log(chemical_creator_params['intensity_range'][0])
        max_log_intensity = np.log(chemical_creator_params['intensity_range'][1])
        n_chemicals_range = chemical_creator_params['n_chemicals']
        if n_chemicals_range[0] == n_chemicals_range[1]:
            n_chems = n_chemicals_range[0]
        else:
            n_chems = randrange(n_chemicals_range[0], n_chemicals_range[1])
        df = UniformMZFormulaSampler(min_mz=min_mz, max_mz=max_mz)
        ris = UniformRTAndIntensitySampler(min_rt=min_rt, max_rt=max_rt,
                                           min_log_intensity=min_log_intensity, max_log_intensity=max_log_intensity)
        cm = ChemicalMixtureCreator(df, rt_and_intensity_sampler=ris)
        chems = cm.sample(n_chems, 2, include_adducts_isotopes=False)
        return chems

    def _reset_mass_spec(self, chems, env_params, noise_params):
        """
        Generates new mass spec
        """
        noise_density = noise_params['noise_density']
        noise_max_val = noise_params['noise_max_val']
        noise_min_mz = noise_params['mz_range'][0]
        noise_max_mz = noise_params['mz_range'][1]
        spike_noise = UniformSpikeNoise(noise_density, noise_max_val, min_mz=noise_min_mz, max_mz=noise_max_mz)
        ionisation_mode = env_params['ionisation_mode']
        mass_spec = IndependentMassSpectrometer(ionisation_mode, chems, None, spike_noise=spike_noise)
        return mass_spec

    def _reset_controller(self, env_params):
        """
        Generates new controller
        """
        ionisation_mode = env_params['ionisation_mode']
        N = env_params['N']
        isolation_window = env_params['isolation_window']
        mz_tol = env_params['mz_tol']
        rt_tol = env_params['rt_tol']
        min_ms1_intensity = env_params['min_ms1_intensity']
        controller = TopNController(ionisation_mode, N, isolation_window, mz_tol, rt_tol, min_ms1_intensity,
                                    ms1_shift=0,
                                    initial_exclusion_list=None, force_N=False)
        return controller

    def _reset_vimms_environment(self, mass_spec, controller, env_params):
        """
        Generates new ViMMS environment to run controller and mass spec together
        """
        min_rt = env_params['rt_range'][0]
        max_rt = env_params['rt_range'][1]
        vimms_env = Environment(mass_spec, controller, min_rt, max_rt, progress_bar=False)
        return vimms_env

    def _handle_acquisition_open(self):
        """
        Open acquisition and generates an MS1 scan to process
        """
        logger.debug('Acquisition open')
        # send the initial custom scan to start the custom scan generation process
        params = self.controller.get_initial_scan_params()

        # unlike the normal Vimms environment, here we generate scan but don't call the controller yet (time is also not incremented)
        self.scan_to_process = self.mass_spec.step(params=params, call_controller=False)

    def _get_state(self, scan_to_process):
        """
        Converts a scan to a state
        """
        mzs, rt, intensities = self._get_mzs_rt_intensities(scan_to_process)
        included_intensities = []
        for mz, intensity in zip(mzs, intensities):
            if not self.controller.exclusion.is_excluded(mz, rt):
                included_intensities.append(intensity)
        included_intensities = np.array(included_intensities)

        above_threshold = included_intensities > self.controller.min_ms1_intensity
        below_threshold = included_intensities <= self.controller.min_ms1_intensity
        num_above = np.sum(above_threshold)
        num_below = np.sum(below_threshold)
        sum_above = np.log(sum(included_intensities[above_threshold]))
        sum_below = np.log(sum(included_intensities[below_threshold]))
        min_above = np.log(min(included_intensities[above_threshold]))
        max_below = np.log(max(included_intensities[below_threshold]))

        features = np.zeros(self.in_dim)
        features[0] = num_above
        features[1] = num_below
        features[2] = sum_above
        features[3] = sum_below
        features[4] = min_above
        features[5] = max_below

        sorted_intensities = sorted(included_intensities, reverse=True)
        features[6:20] = np.log(sorted_intensities[0:14])

        for i in range(len(features)):
            if np.isnan(features[i]): features[i] = 0
        return features

    def _get_mzs_rt_intensities(self, scan_to_process):
        """
        Extracts mzs, rt, and intensities values from a scan
        """
        mzs = scan_to_process.mzs
        intensities = scan_to_process.intensities
        rt = scan_to_process.rt
        assert mzs.shape == intensities.shape
        return mzs, rt, intensities

    def render(self, mode='human', close=False):
        """
        Render the environment to the screen
        """
        logger.info('step %d %s reward %f done %s' % (self.step_no, self.last_processed_scan,
                                                           self.last_reward, self.episode_done))
